# Умножение элементов списка на множитель

# функция
def get_sp() -> list:
    while True:
        try:
            sp1 = input("Введите список чисел через пробел: ").strip()
            return [int(y) for y in sp1.split()] if sp1 else []
        except ValueError:
            print("Ошибка: вводите только числа, разделенные пробелами!")


def get_mn() -> int:
    while True:
        try:
            ch1 = input("Введите множитель (по умолчанию 2): ").strip()
            return int(ch1) if ch1 else 2
        except ValueError:
            print("Ошибка: множитель должен быть числом!")

def list1 (sp: list, ch: int = 2) -> list:
    return [x * ch for x in sp]

sp_r = get_sp()
ch_r = get_mn()

result = list1 (sp_r, ch_r)
print("Результат (функция):", result)

# лямбда
while True:
    try:
        l_get_sp = lambda sp01=input("Введите список чисел через пробел: ").strip(): list(map(int, sp01.split())) if sp01 else []
        sp0 = l_get_sp()
        break
    except ValueError:
        print("Ошибка: вводите только числа, разделенные пробелами!")

while True:
    try:
        l_get_mnz =lambda  ch01 = input("Введите множитель (по умолчанию 2): ").strip(): int(ch01) if ch01 else 2
        ch0 = l_get_mnz()
        break
    except ValueError:
        print("Ошибка: множитель должен быть числом!")



result0 = list(map(lambda c0: c0 * ch0, sp0))
print("Результат (lambda):", result0)

# Пояснение кода:
# Функция
# сначала создаем функцию и не принимаем аргументы тк требуется запросить у пользователя ввод и вернуть
# список чисел
# с помощью аннотации -> list мы обозначаем что функция должна вернуть список значений но аннотация это не строгая проверка типов
# поэтому не гарантирует возвращения именно списка но помогает в поиске ошибок разработчику
# поэтому далее в return используется опр синтаксис для создания списка - [] (т.е. list[int]) и преобразуем элементы в инт
# если их не преобразовать программа воспринимает числа как строку и дублирует ее в количестве множителя
# такое же преобразование делается для множителя, но там не требуется список и перебор элементов тк мы вводим только
# одно число
# далее используем цикл чтобы при обработке ошибки(исключения) программа предложила снова ввести число
# и используем try-except где в блоке try где выполняется код и если происходит какая либо ошибка перехватывает ее
# в блоке except чтобы программа не аварийно завершилась
# далее мы перебираем все элементы в списке и преобразуем их в int если значения введены если нет то возвращаем пустой список
# похожим образом работает следующая функция (почему используется и аннотация и типизация в самом return описывала выше)
# в функции list1 мы также используем аннотацию для переменных и задаем дефолтное значение 2 для множителя
# при этом выше уже есть return int(ch1) if ch1 else 2
# потому что get_mnoz это отдельная функция, которая может использоваться не только для list1
# в данном случае можно считать что в list это доп страховка, если функция будет вызвана без указания ch она также автоматически станет 2
# далее мы вызываем функции передавая введенные значения в переменные, вызываем третью функцию которая принимает эти сохраненные в переменные значения
# и возвращает новый список сохраненный в новую переменную и далее выводим этот новый список

# Лямбда
# используется для не сложной логики
# поэтому запись в виде лямбда функции выполняет практически те же действия что и в функции выше
# в данном случае вызов функции написан сразу в цикле а не отдельно как было в функции
# лямбда создаётся с аргументом по умолчанию sp01=input() поэтому input выполняется сразу при создании лямбды а не при ее вызове
# и при вызове используется значение которое уже введено и преобразует его в список чисел/число
# если этого не происходит (введено не число) то обрабатывается исключение
# поэтому вызов функции внутри цикла нужно чтобы при ошибке пересоздать лямбду и вызвать input заново
# также здесь используется list(map())
# list(map) применяет функцию к каждому элементу итерируемого объекта те это было бы аналогично int(y) for y in sp1.split()
# т е map преобразует каждое число из списка sp1.split() в int но map не создает список а возвращает итератор те не хранит все
# элементы в памяти сразу, поэтому его
# требуется явно преобразовать его в список с помощью list
# написать [map] нельзя тк программа выведет сам итератор map а не преобразует данные из него в новый список
# в результате мы внутри мап создаем лямбда функцию и мап применяет (те сама вызывает функцию) ее к каждому элементу списка и затем с помощью лист преобразует
# в готовый список ну и затем выводим