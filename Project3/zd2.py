# Калькулятор
def plus(a, b):
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise TypeError("Ошибка: Вы ввели что-то другое! Введите по одному числу.")
    return a + b

def minus(a, b):
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise TypeError("Ошибка: Вы ввели что-то другое! Введите по одному числу.")
    return a - b

def multiply(a, b):
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise TypeError("Ошибка: Вы ввели что-то другое! Введите по одному числу.")
    return a * b


def divide(a, b):
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise TypeError("Ошибка: Вы ввели что-то другое! Введите по одному числу.")
    if b == 0:
        raise ZeroDivisionError("Деление на ноль невозможно")
    return a / b




def power(a, b):
    if not (isinstance(a, (int, float)) and isinstance(b, (int, float))):
        raise TypeError("Ошибка: Вы ввели что-то другое! Введите по одному числу.")
    return a ** b



def factorial(n):
    if not isinstance(n, int):
        raise TypeError("Ошибка: Вы ввели что-то другое! Введите одно целое число.")
    if n < 0:
        raise ValueError("Ошибка: Факториал не может быть отрицательным.")
    if n == 0:
        return 1
    return n * factorial(n - 1)




def root(a):
    if not isinstance(a, (int, float)):
        raise TypeError("Ошибка: Вы ввели что-то другое! Введите одно число.")
    if a < 0:
        raise ValueError("Ошибка: Квадратный корень не должен быть отрицательным.")
    return a ** 0.5



def mean(numbers):
    if not isinstance(numbers, list):
        raise TypeError("Аргумент должен быть списком")
    if not numbers:
        raise ValueError("Список чисел не может быть пустым")
    for num in numbers:
        if not isinstance(num, (int, float)):
            raise TypeError("Все элементы списка должны быть числами")
    return sum(numbers) / len(numbers)



def calculator():
    operations = {
        '1': ('Сложение', plus),
        '2': ('Вычитание', minus),
        '3': ('Умножение', multiply),
        '4': ('Деление', divide),
        '5': ('Возведение в степень', power),
        '6': ('Факториал', factorial),
        '7': ('Квадратный корень', root),
        '8': ('Среднее арифметическое', mean)
    }

    while True:
        print("Доступные операции:")
        for key, value in operations.items():
            print(f"{key}. {value[0]}")
        print("________________")

        operation = input("Операция: ").strip()

        if operation.lower() == 'exit':
            print("Выход из калькулятора")
            break

        if operation not in operations:
            print("Неверный выбор операции. Попробуйте снова.")
            continue

        try:
            func = operations[operation][1]
            result = None

            if operation in ('1', '2', '3', '4', '5'):
                a = float(input("Введите первое число: "))
                b = float(input("Введите второе число: "))
                result = func(a, b)
            elif operation == '6':
                n = int(input("Введите целое число: "))
                result = func(n)
            elif operation == '7':
                a = float(input("Введите число: "))
                result = func(a)
            elif operation == '8':
                nums = input("Введите числа через пробел: ").split()
                nums = [float(num) for num in nums]
                result = func(nums)

            if isinstance(result, float) and result.is_integer():
                result = int(result)
            print(f"Результат: {result}")

        except ValueError as e:
            print(f"Ошибка: {e}")
        except TypeError as e:
            print(f"Ошибка: {e}")
        except ZeroDivisionError as e:
            print(f"Ошибка: {e}")
        except Exception as e:
            print(f"Произошла непредвиденная ошибка: {e}")


calculator()

#
# Пояснение кода:
# я решила не писать остаток от деления и деление нацело тк это было не обязательно
# сначала создаю функции для вычисления различных операций
# все создаю примерно по одному принципу
# isinstance() проверяет принадлежит ли объект к указанному типу данных или кортежу типов
# в данном случе кортеж тк объект может быть и int и float
# для примера в isinstance(a, (int, float)) проверяется является ли аргумент a числом типа int или float
# далее по условие если хоть какой то из аргументов не число то обрабатывается исключение типа
# TypeError: возникает, если операция или функция применяется к значению недопустимого типа (встроенное исключение)
# также далее буду использовать ValueError: возникает, если операция или функция получают объект корректного типа с некорректным значением
# и ZeroDivisionError: возникает при делении на ноль
# это конкретные типы исключений которые наследуются от базовых
# а также использую Exception: базовый тип, который обычно применяется для создания своих типов исключений
# также некоторые эти типы я использую в других заданиях, но прописываю об этом тут тк делаю в разном порядке задания
# далее возвращается выражение с сохранением используемого типа
# все функции я прописала похожим образом с добавлением других условий или ошибок в зависимости
# от логики выполнения выражения
# например для деления если знаменатель равен нулю обрабатывается исключение if b == 0:
#         raise ZeroDivisionError("Деление на ноль невозможно")
# для вызова исключений вручную по условию задания используется  raise
# try except перехватывают исключения в коде (в том числе и raise) а raise генерирует исключение
# вручную и используется когда нужно сообщить об ошибке и остановить выполнение
# проще говоря raise для резкой остановки а try except для мягкой обработки ошибок
#
# хочу отдельно рассмотреть как выполняется логика некоторых функций
# для факториала мы возвращаем return n * factorial(n - 1) с помощью рекурсии
# она делает проверку каждого нового факториала до момента проверки на 0 где
# возвращает 1 а тк число не может быть отрицательным то уменьшение прекращается и
# рекурсия "сворачивается" обратно умножая каждое значение в обратном порядке
#
# в среднем арифметическом мы проверяем что элемент список
# затем то что он не пустой
# затем то что каждый элемент в списке - число
# и рассчитываем среднее арифметическое с помощью функции sum возвращает сумму всех элементов списка numbers деленной на
# len которая возвращает кол-во эл-ов в списке
#
#
# после этого создаем основную функцию калькулятора которая реализует интерфейс
# создаётся словарь операция, где ключи - цифры меню, а значения - кортежи из названия
# операции и соответствующей функции
# калькулятор работает в бесконечном цикле, пока пользователь не введёт exit
# operations.items() возвращает пары "ключ-значение" из словаря operations
# цикл последовательно перебирает все элементы словаря
# На каждой итерации key получает значение ключа а value получает кортеж значений
# {key} подставляет текущий ключ {value[0]} берет первый элемент кортежа (название операции)
# далее делаем ввод для 1 операции
# если введено exit калькулятор завершает работу
# если введённый номер не '1'–'8', выводится сообщение об ошибке, и цикл начинается заново
# в func = operations[operation][1] извлекаем кортеж значений по ключу и обращаемся ко второму элементу кортежа
# то есть к функции которую вызываем для вычислений
# result = None инициализирует result и указывает что там пока что нет значений
# без явного указания может возникнуть ошибка тк иначе переменной не будет существовать
#
# далее прописываем операции где используются только 2 числа a и b
# проверяется содержится ли значение переменной operation в кортеже
# func содержит одну из функций и условно если  operation='1', то func = plus
# значит result = plus(a, b)
# функция получает два числ, выполняет операцию и возвращает результат
#
# в среднем арифметическом
# запрашивает несколько чисел через пробел
# преобразует строки в числа и вызывает функцию mean с списком чисел
#
# после для результата проверяется является ли result числом с плавающей точкой (тип float)
# и представляет ли число целое значение (дробная часть равна 0)
# если условие выполняется то int(result) преобразует float в int
#
# после всего следует блок except где если на каком-то этапе возникает
# ошибка, она перехватывается и выводится понятное сообщение
# try-except нужны здесь для перехвата ошибки тк оно ловит исключение когда raise только его создает
# raise только создаёт ошибку, но не обрабатывает её
# а в функции калькулятора эти ошибки ловятся и корректно обрабатываются try-except